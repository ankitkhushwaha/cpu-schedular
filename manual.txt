add support for rest of algos
add support for multiple cpu
write report
add githooks for format code
refractor cpu_scheduling/cpu_thread.c
io process is same as cpu -> single threaded

A. First In First Out (FIFO)
    Data structure: simple queue.
    Dequeue rule: head of queue.
    CPU runs that process until it finishes.
    No preemption.

B. Non-preemptive Shortest Job First (SJF)
    Data structure: priority queue, ordered by burst time.
    Dequeue rule: pick the process with smallest CPU burst among those ready.
    CPU runs it until it finishes.
    Still no preemption.

C. Preemptive Shortest Job First (SRTF â€“ Shortest Remaining Time First)
    Data structure: priority queue, ordered by remaining burst time.
    Dequeue rule: always pick process with shortest remaining time.
    Preemption happens: if a new process arrives with shorter burst than the current one â†’ current is paused and re-enqueued.
    So here dequeue isnâ€™t just at completionâ€”it can happen mid-burst.

    Event-driven approach:
        Preemption check is triggered only on process arrival.
        Arrival thread signals the scheduler.
        Scheduler compares new front vs current.

    Tick-driven approach:

        Every CPU tick, scheduler compares current vs ready_queue.front.
        If no new arrivals, condition will always fail anyway.
        If new arrivals, condition succeeds immediately.

D. Round Robin (RR)
    Data structure: simple queue (like FIFO).
    Dequeue rule: head of queue.
    CPU runs that process for time_quantum only.
    If process finishes early â†’ remove.
    If not â†’ preempt and re-enqueue at tail.
    Preemption always after quantum.

ðŸ‘‰ So:
A = normal queue.
B = priority queue (non-preemptive).
C = priority queue (preemptive).
D = queue + time slicing.